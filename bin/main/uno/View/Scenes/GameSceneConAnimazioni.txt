package uno.View.Scenes;

import uno.Model.Cards.Card;
import uno.Model.Game.Game;
import uno.Model.Game.GameState;
import uno.Model.Cards.Attributes.CardColor;
import uno.Model.Cards.Attributes.CardValue;
import uno.Model.Player.Player;
import uno.Controller.GameViewObserver;
import uno.View.GameModelObserver;
import uno.View.Components.ColorChooserPanel;

// Imports per le Immagini
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import java.awt.Image;
import java.net.URL;
import java.io.IOException;
import java.util.Map;
import java.util.HashMap;
import java.awt.AlphaComposite;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

// Imports per Swing
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JLayeredPane; // Per animazioni
import javax.swing.JPanel;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities; // Per animazioni
import javax.swing.Timer; // Per animazioni
import javax.swing.border.Border;
import javax.swing.Box;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Cursor;
import java.awt.GridBagLayout;
import java.awt.Point; // Per animazioni
import java.awt.event.ComponentAdapter; // Per animazioni
import java.awt.event.ComponentEvent; // Per animazioni
import javax.swing.border.EmptyBorder;
import javax.swing.border.TitledBorder;

/**
 * Pannello (JPanel) che rappresenta la schermata di gioco principale.
 * Implementa GameModelObserver per essere aggiornata dal modello Game.
 * Versione con grafica moderna e layout per 4 giocatori.
 */
public class GameScene extends JPanel implements GameModelObserver {

    // --- Colori e Font (come MenuScene) ---
    private static final Color BACKGROUND_COLOR = new Color(30, 30, 30);
    private static final Color PANEL_COLOR = new Color(50, 50, 50);
    private static final Color TEXT_COLOR = Color.WHITE;
    private static final Color BUTTON_COLOR_DRAW = new Color(33, 150, 243); // Blu
    private static final Color BUTTON_COLOR_PASS = new Color(244, 67, 54); // Rosso
    private static final Font BOLD_FONT = new Font("Arial", Font.BOLD, 14);
    private static final Font NORMAL_FONT = new Font("Arial", Font.PLAIN, 12);
    private static final Border HIGHLIGHT_BORDER = BorderFactory.createLineBorder(Color.ORANGE, 3);
    private static final Border NORMAL_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3); // Spessore per allineamento

    private final Game gameModel;
    private GameViewObserver controllerObserver;

    // --- Dimensioni Carte ---
    private static final int CARD_WIDTH = 80;
    private static final int CARD_HEIGHT = 120;

    // --- Pannelli Giocatori ---
    private JPanel playerHandPanel; // Sud (Umano)
    private JPanel westAIPanel, northAIPanel, eastAIPanel; // Ovest, Nord, Est (IA)
    private JLabel westAILabel, northAILabel, eastAILabel;

    private final Map<String, ImageIcon> cardImageCache;
    private final Map<String, ImageIcon> transparentImageCache;

    // --- Pannelli Centrali ---
    private JPanel centerPanel;
    private JLabel discardPileCard;
    private JButton drawDeckButton;
    private JButton passButton;
    
    // --- Pannelli Laterali (Est) ---
    private JLabel statusLabel;
    private JButton unoButton;
    private JButton settingsButton; // Bottone Menu
    private ColorChooserPanel colorChooserPanel;

    // --- Pannelli per Animazione ---
    private JLayeredPane layeredPane;
    private JPanel mainGamePanel;

    public GameScene(Game gameModel) {
        // 1. Setup Base: La GameScene ora usa un BorderLayout
        super(new BorderLayout());
        this.gameModel = gameModel;
        this.gameModel.addObserver(this);

        // 2. Inizializza la cache e carica le immagini
        this.cardImageCache = new HashMap<>();
        this.transparentImageCache = new HashMap<>();
        loadCardImages();
        
        setBackground(BACKGROUND_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // 3. Setup LayeredPane per Animazioni
        layeredPane = new JLayeredPane();
        add(layeredPane, BorderLayout.CENTER); // Il layeredPane riempie la scena

        // 4. Setup Pannello di Gioco Principale
        // Questo pannello conterrà il layout di gioco (Nord, Sud, Est, Ovest, Centro)
        mainGamePanel = new JPanel(new BorderLayout(10, 10));
        mainGamePanel.setOpaque(false); // Trasparente per mostrare BACKGROUND_COLOR
        layeredPane.add(mainGamePanel, JLayeredPane.DEFAULT_LAYER);

        // Questo ComponentAdapter assicura che il mainGamePanel riempia
        // sempre il layeredPane quando la finestra viene ridimensionata.
        layeredPane.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                mainGamePanel.setBounds(0, 0, layeredPane.getWidth(), layeredPane.getHeight());
            }
        });

        // --- Creazione Pannelli ---
        // (I metodi helper inizializzano i campi)
        playerHandPanel = createPlayerHandPanel();
        centerPanel = createCenterPanel();
        
        // Pannelli IA (Ovest, Nord, Est)
        westAIPanel = createOpponentPanel("IA-Ovest (1)");
        northAIPanel = createOpponentPanel("IA-Nord (2)");
        eastAIPanel = createOpponentPanel("IA-Est (3)");

        // Pannello Est (Info + Scelta Colore + IA Est)
        JPanel eastContainer = createEastContainer();

        // --- Assemblaggio Layout (NEL mainGamePanel) ---
        mainGamePanel.add(northAIPanel, BorderLayout.NORTH);
        mainGamePanel.add(westAIPanel, BorderLayout.WEST);
        mainGamePanel.add(eastContainer, BorderLayout.EAST);
        mainGamePanel.add(centerPanel, BorderLayout.CENTER);
        
        // Pannello Sud (Mano Umano + Bottone UNO)
        JPanel southPanel = new JPanel(new BorderLayout(10, 0));
        southPanel.setOpaque(false);
        southPanel.add(new JScrollPane(playerHandPanel), BorderLayout.CENTER);
        
        JPanel unoButtonPanel = new JPanel(new BorderLayout());
        unoButtonPanel.setOpaque(false);
        unoButtonPanel.setBorder(new EmptyBorder(0, 0, 10, 10));
        this.unoButton = createStyledButton("UNO!", new Color(255, 193, 7), Color.BLACK, 100, 80); // Giallo
        unoButtonPanel.add(this.unoButton, BorderLayout.CENTER);
        
        southPanel.add(unoButtonPanel, BorderLayout.EAST);
        mainGamePanel.add(southPanel, BorderLayout.SOUTH);

        // --- Collegamento Azioni -> Controller ---
        drawDeckButton.addActionListener(e -> {
            if (controllerObserver != null) { controllerObserver.onDrawCard(); }
        });
        passButton.addActionListener(e -> {
            if (controllerObserver != null) { controllerObserver.onPassTurn(); }
        });
        unoButton.addActionListener(e -> {
            if (controllerObserver != null) { controllerObserver.onCallUno(); }
        });
        settingsButton.addActionListener(e -> {
            if (controllerObserver != null) { controllerObserver.onBackToMenu(); }
        });
        
        onGameUpdate(); // Prima visualizzazione
    }

    /**
     * Imposta l'observer (controller) che ascolterà gli eventi di questa scena.
     * @param observer L'observer del controller.
     */
    public void setObserver(GameViewObserver observer) {
        this.controllerObserver = observer;
        this.colorChooserPanel.setObserver(observer);
    }

    /**
     * Abilita o disabilita tutti i controlli di input umano.
     */
    public void setHumanInputEnabled(boolean enabled) {
        // Il bottone Menu rimane sempre attivo
        if (this.settingsButton != null) {
            this.settingsButton.setEnabled(true);
        }
        
        this.unoButton.setEnabled(enabled);
        
        boolean isHumanTurn = gameModel.getCurrentPlayer().getClass() == Player.class;
        boolean hasDrawn = gameModel.hasCurrentPlayerDrawn(gameModel.getCurrentPlayer());
        
        this.drawDeckButton.setEnabled(enabled && !hasDrawn);
        this.passButton.setEnabled(enabled && hasDrawn);

        for (Component comp : playerHandPanel.getComponents()) {
            if (comp instanceof JButton) {
                comp.setEnabled(enabled);
            }
        }
        
        if (!enabled && !isHumanTurn) {
            colorChooserPanel.setVisible(false);
        }
    }

    /**
     * Metodo chiamato dal Modello (Game) quando lo stato cambia.
     */
    @Override
    public void onGameUpdate() {
        boolean isHumanTurn = gameModel.getCurrentPlayer().getClass() == Player.class;
        boolean isDarkSide = gameModel.isDarkSide();

        // Aggiorna i pulsanti del Color Chooser in base al lato attivo
        this.colorChooserPanel.updateButtons(isDarkSide);

        // --- Gestione Stato (Visibilità) ---
        if (gameModel.getGameState() == GameState.WAITING_FOR_COLOR) {
            setHumanInputEnabled(false);
            if (isHumanTurn) {
                System.out.println("Mostro il pannello di scelta colore.");
                colorChooserPanel.setVisible(true);
            }
            statusLabel.setText("Scegli un colore!");
        } else if (gameModel.getGameState() == GameState.RUNNING) {
            colorChooserPanel.setVisible(false);
            String direction = gameModel.isClockwise() ? "Orario" : "Antiorario";
            statusLabel.setText("<html><div style='text-align: center;'>Turno di: "
                + gameModel.getCurrentPlayer().getName()
                + "<br>Direzione: " + direction + "</div></html>");
        }
        
        // --- Aggiornamento Pila Scarti ---
        if (gameModel.isDiscardPileEmpty()) {
            discardPileCard.setText("Vuota");
            discardPileCard.setIcon(null);
            discardPileCard.setBackground(Color.LIGHT_GRAY);
        } else {
            Card topCard = gameModel.getTopDiscardCard();
            String cardName = topCard.getColor(gameModel).name() + "_" + topCard.getValue(gameModel).name();
            ImageIcon icon = cardImageCache.get(cardName);
            
            CardColor activeColor = gameModel.getCurrentColor();

            if (icon != null) {
                discardPileCard.setIcon(icon);
                discardPileCard.setText(null);
            } else {
                discardPileCard.setIcon(null);
                discardPileCard.setText("<html><div style='text-align: center;'>" + topCard.getValue(gameModel) + "<br>" + topCard.getColor(gameModel) + "</div></html>");
            }

            discardPileCard.setBorder(BorderFactory.createLineBorder(convertCardColor(activeColor), 4));
        }

        // --- Aggiornamento Mano Umano (con Logica Animazione) ---
        Player humanPlayer = gameModel.getPlayers().get(0);
        int modelHandSize = humanPlayer.getHand().size();
        int viewHandSize = playerHandPanel.getComponentCount();

        // Controlla se il modello ha più carte di quante ne mostriamo
        // (e se è il turno dell'umano, per evitare animazioni quando pesca l'IA)
        if (modelHandSize > viewHandSize && isHumanTurn && gameModel.getGameState() == GameState.RUNNING) {
            // È stata pescata una carta! Avvia l'animazione.
            setHumanInputEnabled(false);
            playDrawAnimation(cardImageCache.get("CARD_BACK"));
        } else {
            updatePlayerHandPanel();
            setHumanInputEnabled(isHumanTurn && gameModel.getGameState() == GameState.RUNNING);
        }
        
        // --- Aggiornamento Pannelli IA ---
        updateOpponentPanel(westAIPanel, westAILabel, gameModel.getPlayers().get(1));
        updateOpponentPanel(northAIPanel, northAILabel, gameModel.getPlayers().get(2));
        updateOpponentPanel(eastAIPanel, eastAILabel, gameModel.getPlayers().get(3));

        mainGamePanel.revalidate();
        mainGamePanel.repaint();
    }
    
    /**
     * Aggiorna la UI della mano del giocatore (chiamato dopo le animazioni).
     */
    private void updatePlayerHandPanel() {
        playerHandPanel.removeAll();
        Player humanPlayer = gameModel.getPlayers().get(0);
        for (Card card : humanPlayer.getHand()) {
            JButton cardButton = createCardButton(card);
            cardButton.addActionListener(e -> {
                if (controllerObserver != null) {
                    //controllerObserver.onPlayCard(card);
                    playDiscardAnimation(card, (JButton) e.getSource());
                }
            });
            playerHandPanel.add(cardButton);
        }
        playerHandPanel.revalidate();
        playerHandPanel.repaint();
    }

    /**
     * Mostra un popup che annuncia il vincitore e offre opzioni di fine partita.
     * @param winnerName Il nome del giocatore che ha vinto.
     */
    public void showWinnerPopup(String winnerName) {
        setHumanInputEnabled(false);

        // 1. Definisce le opzioni dei pulsanti
        Object[] options = {
            "Torna al Menu",  // Opzione 0
            "Nuova Partita", // Opzione 1
            "Chiudi Gioco"   // Opzione 2
        };

        // 2. Mostra il popup personalizzato
        int choice = JOptionPane.showOptionDialog(
            this,                                     // Parent component
            winnerName + " ha vinto la partita!\nCosa vuoi fare?", // Messaggio
            "Partita Terminata",                      // Titolo
            JOptionPane.YES_NO_CANCEL_OPTION,         // Tipo di opzioni
            JOptionPane.INFORMATION_MESSAGE,          // Tipo di icona
            null,                                     // Icona custom (null per default)
            options,                                  // Le opzioni definite sopra
            options[0]                                // Opzione di default
        );

        // 3. Gestisce la scelta dell'utente
        if (controllerObserver != null) {
            switch (choice) {
                case 0: // Torna al Menu
                case 1: // Nuova Partita
                    // Entrambi tornano al menu, da cui si può iniziare una nuova partita
                    controllerObserver.onBackToMenu();
                    break;
                case 2: // Chiudi Gioco
                    System.exit(0);
                    break;
                case JOptionPane.CLOSED_OPTION:
                default:
                    // Se la finestra viene chiusa (X), esce dal gioco.
                    System.exit(0);
                    break;
            }
        }
    }
    
    // --- Metodi Helper per la Creazione GUI ---

    private JPanel createOpponentPanel(String title) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(PANEL_COLOR);
        panel.setBorder(BorderFactory.createTitledBorder(
            BorderFactory.createEtchedBorder(), title,
            TitledBorder.CENTER, TitledBorder.TOP, BOLD_FONT, TEXT_COLOR
        ));
        panel.setPreferredSize(new Dimension(120, 100));

        JLabel cardLabel = new JLabel("X carte");
        cardLabel.setFont(BOLD_FONT);
        cardLabel.setForeground(TEXT_COLOR);
        cardLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        cardLabel.setBorder(new EmptyBorder(10, 10, 10, 10));
        
        // Salva il riferimento alla label corretta
        if (title.contains("Ovest")) { this.westAILabel = cardLabel; }
        else if (title.contains("Nord")) { this.northAILabel = cardLabel; }
        else if (title.contains("Est")) { this.eastAILabel = cardLabel; }
        
        panel.add(Box.createVerticalGlue());
        panel.add(cardLabel);
        panel.add(Box.createVerticalGlue());
        return panel;
    }
    
    private void updateOpponentPanel(JPanel panel, JLabel label, Player ai) {
        label.setText(ai.getHandSize() + " carte");
        if (gameModel.getCurrentPlayer() == ai) {
            panel.setBorder(BorderFactory.createTitledBorder(
                HIGHLIGHT_BORDER, ai.getName(),
                TitledBorder.CENTER, TitledBorder.TOP, BOLD_FONT, Color.ORANGE
            ));
        } else {
            panel.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createEtchedBorder(), ai.getName(),
                TitledBorder.CENTER, TitledBorder.TOP, BOLD_FONT, TEXT_COLOR
            ));
        }
    }

    private JPanel createCenterPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setOpaque(false);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(10, 10, 10, 10);
        
        this.drawDeckButton = new JButton();
        styleAsCardButton(this.drawDeckButton, "CARD_BACK"); // Usa l'immagine del dorso
        
        this.discardPileCard = new JLabel("SCARTI");
        this.discardPileCard.setPreferredSize(new Dimension(100, 150));
        this.discardPileCard.setFont(BOLD_FONT);
        this.discardPileCard.setHorizontalAlignment(JLabel.CENTER);
        this.discardPileCard.setBorder(BorderFactory.createLineBorder(Color.BLACK));
        this.discardPileCard.setOpaque(true);
        
        this.passButton = createStyledButton("Passa", BUTTON_COLOR_PASS, Color.WHITE, 100, 40);
        
        gbc.gridx = 0; gbc.gridy = 0;
        panel.add(this.drawDeckButton, gbc);
        gbc.gridx = 1; gbc.gridy = 0;
        panel.add(this.discardPileCard, gbc);
        gbc.gridx = 0; gbc.gridy = 1; gbc.gridwidth = 2;
        panel.add(this.passButton, gbc);
        
        return panel;
    }

    private JPanel createPlayerHandPanel() {
        JPanel panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 5, 5));
        panel.setBackground(PANEL_COLOR);
        TitledBorder border = BorderFactory.createTitledBorder(
            BorderFactory.createEtchedBorder(), "La tua Mano",
            TitledBorder.CENTER, TitledBorder.TOP, BOLD_FONT, TEXT_COLOR
        );
        panel.setBorder(border);
        panel.setPreferredSize(new Dimension(100, 150)); // Altezza per le carte
        return panel;
    }

    private JPanel createInfoPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(PANEL_COLOR);
        panel.setBorder(BorderFactory.createTitledBorder(
            BorderFactory.createEtchedBorder(), "Info Partita",
            TitledBorder.LEFT, TitledBorder.TOP, BOLD_FONT, TEXT_COLOR
        ));

        this.statusLabel = new JLabel("Turno di: ... \n Direzione: ...");
        this.statusLabel.setFont(BOLD_FONT);
        this.statusLabel.setForeground(TEXT_COLOR);
        this.statusLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        this.statusLabel.setBorder(new EmptyBorder(10, 10, 10, 10));

        panel.add(this.statusLabel);

        return panel;
    }
    
    /**
     * Crea il pannello per il bottone Impostazioni/Menu.
     */
    private JPanel createSettingsPanel() {
        JPanel panel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        panel.setOpaque(false);
        this.settingsButton = createStyledButton("Menu", new Color(70, 70, 70), Color.WHITE, 80, 30);
        panel.add(this.settingsButton);
        return panel;
    }

    /**
     * Crea il container Est, che ora include il pulsante Menu in alto.
     */
    private JPanel createEastContainer() {
        JPanel eastPanel = new JPanel();
        eastPanel.setLayout(new BoxLayout(eastPanel, BoxLayout.Y_AXIS));
        eastPanel.setOpaque(false);
        
        JPanel settingsPanel = createSettingsPanel();
        JPanel infoPanel = createInfoPanel();
        colorChooserPanel = new ColorChooserPanel();
        
        eastPanel.add(settingsPanel); // Bottone Menu in alto
        eastPanel.add(Box.createRigidArea(new Dimension(0, 15)));
        eastPanel.add(eastAIPanel); // Pannello IA Est
        eastPanel.add(Box.createRigidArea(new Dimension(0, 15)));
        eastPanel.add(infoPanel);
        eastPanel.add(Box.createRigidArea(new Dimension(0, 15)));
        eastPanel.add(colorChooserPanel);
        eastPanel.add(Box.createVerticalGlue()); // Spinge tutto in alto
        return eastPanel;
    }

    /**
     * Applica stile-carta a un JButton.
     */
    private void styleAsCardButton(JButton button, String cardName) {
        ImageIcon icon = cardImageCache.get(cardName);
        ImageIcon transparentIcon = transparentImageCache.get(cardName);
        if (icon != null) {
            button.setIcon(icon);
            button.setDisabledIcon(transparentIcon);
            button.setText(null);
        } else {
            button.setText(cardName.replace("_", " "));
            button.setForeground(Color.WHITE);
        }
        
        button.setPreferredSize(new Dimension(CARD_WIDTH, CARD_HEIGHT));
        button.setBorder(BorderFactory.createEmptyBorder());
        button.setContentAreaFilled(false);
        button.setFocusPainted(false);
        button.setCursor(new Cursor(Cursor.HAND_CURSOR));
    }
    
    private JButton createCardButton(Card card) {
        String cardName = card.getColor(gameModel).name() + "_" + card.getValue(gameModel).name();
        JButton button = new JButton();
        styleAsCardButton(button, cardName);
        return button;
    }
    
    private JButton createStyledButton(String text, Color bg, Color fg, int width, int height) {
        JButton button = new JButton(text);
        button.setFont(BOLD_FONT);
        button.setBackground(bg);
        button.setForeground(fg);
        button.setOpaque(true);
        button.setBorderPainted(false);
        button.setFocusPainted(false);
        button.setPreferredSize(new Dimension(width, height));
        button.setCursor(new Cursor(Cursor.HAND_CURSOR));
        return button;
    }
    
    private Color convertCardColor(CardColor cardColor) {
        if (cardColor == null) return Color.BLACK; // Colore Jolly attivo
        
        // Colori aggiunti per il lato scuro
        switch (cardColor) {
            case RED: return new Color(211, 47, 47);
            case BLUE: return new Color(33, 150, 243);
            case GREEN: return new Color(76, 175, 80);
            case YELLOW: return new Color(255, 235, 59);
            case PINK: return new Color(255, 105, 180);
            case TEAL: return new Color(0, 128, 128);
            case ORANGE: return new Color(255, 140, 0);
            case PURPLE: return new Color(128, 0, 128);
            case WILD:
            default:
                return Color.DARK_GRAY;
        }
    }

    /**
     * Carica tutte le immagini delle carte in cache all'avvio.
     * QUESTA VERSIONE È CORRETTA per caricare sia i colori chiari CHE scuri.
     */
    private void loadCardImages() {
        // Itera su tutti i colori (RED, YELLOW, GREEN, BLUE, PINK, TEAL, ORANGE, PURPLE)
        for (CardColor color : CardColor.values()) {
            if (color == CardColor.WILD) continue; // WILD non è un colore di carta, è un tipo
            
            // Itera su tutti i valori (ZERO, ONE, ..., SKIP, REVERSE, ..., DRAW_FIVE, etc.)
            for (CardValue value : CardValue.values()) {
                
                // Salta i valori che esistono solo in combinazione con WILD
                if (value == CardValue.WILD || 
                    value == CardValue.WILD_DRAW_FOUR ||
                    value == CardValue.WILD_DRAW_TWO ||
                    value == CardValue.WILD_DRAW_COLOR) {
                    continue;
                }
                
                // Crea nomi validi come "RED_ONE", "BLUE_SKIP", "PINK_FIVE", "TEAL_DRAW_FIVE"
                String cardName = color.name() + "_" + value.name();
                loadImage(cardName);
            }
        }
        
        // Carica le carte WILD (che non hanno colore, il loro colore è "WILD")
        // Il nome file per queste è WILD_ più il loro valore
        loadImage("WILD_WILD");
        loadImage("WILD_WILD_DRAW_FOUR");
        loadImage("WILD_WILD_DRAW_TWO"); 
        loadImage("WILD_WILD_DRAW_COLOR");
        
        // Carica il dorso della carta
        loadImage("CARD_BACK");
    }


    /**
     * Metodo helper per caricare una singola immagine nella cache.
     * @param cardName Il nome del file (es. "RED_ONE")
     */
    private void loadImage(String cardName) {
        try {
            String path = "/images/cards/" + cardName + ".png";
            URL imgURL = getClass().getResource(path);

            if (imgURL != null) {
                ImageIcon icon = new ImageIcon(imgURL);
                Image scaledImg = icon.getImage().getScaledInstance(CARD_WIDTH, CARD_HEIGHT, Image.SCALE_SMOOTH);
                ImageIcon scaledIcon = new ImageIcon(scaledImg);
                cardImageCache.put(cardName, scaledIcon);
                transparentImageCache.put(cardName, createTransparentIcon(scaledIcon, 0.5f));
            } else {
                // Non stampare errore per carte che non esistono (es. RED_DRAW_FIVE)
                // System.err.println("Immagine non trovata: " + path);
            }
        } catch (Exception e) {
            System.err.println("Errore durante il caricamento di: " + cardName);
            e.printStackTrace();
        }
    }

    /**
     * Crea una versione semitrasparente di una ImageIcon.
     */
    public ImageIcon createTransparentIcon(ImageIcon original, float alpha) {
        Image originalImage = original.getImage();
        int width = original.getIconWidth();
        int height = original.getIconHeight();
        BufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = newImage.createGraphics();
        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
        g2d.drawImage(originalImage, 0, 0, null);
        g2d.dispose();
        return new ImageIcon(newImage);
    }
    
    // --- METODI PER L'ANIMAZIONE ---
    
    /**
     * Esegue l'animazione di una carta che si sposta dal mazzo alla mano.
     * @param cardIcon L'icona da animare (solitamente il dorso, CARD_BACK).
     */
    private void playDrawAnimation(ImageIcon cardIcon) {
        // 1. Crea la "carta volante"
        JLabel flyingCard = new JLabel(cardIcon);
        flyingCard.setSize(CARD_WIDTH, CARD_HEIGHT);

        // 2. Calcola coordinate
        // Converte le coordinate locali del bottone in coordinate globali del LayeredPane
        Point startPoint = SwingUtilities.convertPoint(drawDeckButton.getParent(), drawDeckButton.getLocation(), layeredPane);
        
        // Cerca di centrare l'arrivo sulla mano
        Point endPoint = SwingUtilities.convertPoint(playerHandPanel.getParent(), playerHandPanel.getLocation(), layeredPane);
        endPoint.x = layeredPane.getWidth() / 2; // Centra orizzontalmente
        endPoint.y = endPoint.y + 20; // Leggero offset

        // Posizione iniziale
        flyingCard.setLocation(startPoint);

        // 3. Aggiungi la carta al layer superiore (sopra tutto il resto)
        layeredPane.add(flyingCard, JLayeredPane.PALETTE_LAYER); // PALETTE_LAYER è sopra DEFAULT_LAYER

        // 4. Configura il Timer per l'animazione
        int duration = 300; // 0.3 secondi
        int steps = 20;
        int delay = duration / steps;
        
        double dx = (endPoint.x - startPoint.x) / (double)steps;
        double dy = (endPoint.y - startPoint.y) / (double)steps;
        
        final int[] currentStep = {0};

        Timer timer = new Timer(delay, e -> {
            currentStep[0]++;
            
            int newX = (int)(startPoint.x + (dx * currentStep[0]));
            int newY = (int)(startPoint.y + (dy * currentStep[0]));
            
            flyingCard.setLocation(newX, newY);

            if (currentStep[0] >= steps) {
                // Animazione finita
                ((Timer)e.getSource()).stop();
                layeredPane.remove(flyingCard); // Rimuovi la carta volante
                
                // ORA aggiorna la mano per mostrare la nuova carta
                updatePlayerHandPanel();
                
                // Ri-abilita l'input
                boolean isHumanTurn = gameModel.getCurrentPlayer().getClass() == Player.class;
                setHumanInputEnabled(isHumanTurn && gameModel.getGameState() == GameState.RUNNING);
                
                // Ripulisci il layeredPane
                layeredPane.revalidate();
                layeredPane.repaint();
            }
        });

        timer.setRepeats(true);
        timer.start();
    }

    /**
     * Esegue l'animazione di una carta che si sposta dalla mano alla pila degli scarti.
     * @param card La carta logica (Model) da giocare.
     * @param clickedButton Il bottone (View) che è stato cliccato.
     */
    private void playDiscardAnimation(Card card, JButton clickedButton) {
        Card topCard = gameModel.getTopDiscardCard();

        if (card.canBePlayedOn(topCard, gameModel)) {
            // 1. Ottieni l'icona dal bottone cliccato
            ImageIcon cardIcon = (ImageIcon) clickedButton.getIcon();
            if (cardIcon == null) return; // Non animare se non c'è icona

            // 2. Disabilita l'input
            setHumanInputEnabled(false);

            // 3. Crea la "carta volante"
            JLabel flyingCard = new JLabel(cardIcon);
            flyingCard.setSize(CARD_WIDTH, CARD_HEIGHT);

            // 4. Calcola coordinate
            // Punto di partenza: la posizione del bottone cliccato
            Point startPoint = SwingUtilities.convertPoint(clickedButton.getParent(), clickedButton.getLocation(), layeredPane);
            
            // Punto di arrivo: la posizione della pila degli scarti
            Point endPoint = SwingUtilities.convertPoint(discardPileCard.getParent(), discardPileCard.getLocation(), layeredPane);
            
            // Centra la carta sull'etichetta di scarto
            endPoint.x += (discardPileCard.getWidth() - CARD_WIDTH) / 2;
            endPoint.y += (discardPileCard.getHeight() - CARD_HEIGHT) / 2;

            // Posizione iniziale
            flyingCard.setLocation(startPoint);

            // 5. Aggiungi la carta al layer superiore e NASCONDI il bottone originale
            layeredPane.add(flyingCard, JLayeredPane.PALETTE_LAYER);
            clickedButton.setVisible(false); // Nasconde il bottone originale nella mano

            // 6. Configura il Timer per l'animazione
            int duration = 250; // Più veloce della pesca
            int steps = 20;
            int delay = duration / steps;
            
            double dx = (endPoint.x - startPoint.x) / (double)steps;
            double dy = (endPoint.y - startPoint.y) / (double)steps;
            
            final int[] currentStep = {0};

            Timer timer = new Timer(delay, e -> {
                currentStep[0]++;
                
                int newX = (int)(startPoint.x + (dx * currentStep[0]));
                int newY = (int)(startPoint.y + (dy * currentStep[0]));
                
                flyingCard.setLocation(newX, newY);

                if (currentStep[0] >= steps) {
                    // Animazione finita
                    ((Timer)e.getSource()).stop();
                    layeredPane.remove(flyingCard); // Rimuovi la carta volante

                    // 7. ORA chiama il controller per aggiornare il modello
                    // Questo scatenerà un onGameUpdate()
                    if (controllerObserver != null) {
                        controllerObserver.onPlayCard(card);
                    }
                    
                    // onGameUpdate() ridisegnerà la mano (senza più il bottone)
                    // e la pila degli scarti (con la nuova carta in cima).
                    // Non è necessario riabilitare l'input qui, 
                    // perché onGameUpdate() lo gestirà.
                    
                    // Ripulisci il layeredPane
                    layeredPane.revalidate();
                    layeredPane.repaint();
                }
            });

            timer.setRepeats(true);
            timer.start();
        }
    }
}